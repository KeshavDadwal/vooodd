// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.21.0
// source: brands.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createBrand = `-- name: CreateBrand :one
INSERT INTO brands (name, logo, isdeleted, isblocked)
VALUES ($1, $2, $3, $4)
RETURNING id
`

type CreateBrandParams struct {
	Name      string      `json:"name"`
	Logo      pgtype.Text `json:"logo"`
	Isdeleted pgtype.Bool `json:"isdeleted"`
	Isblocked pgtype.Bool `json:"isblocked"`
}

func (q *Queries) CreateBrand(ctx context.Context, arg CreateBrandParams) (int32, error) {
	row := q.db.QueryRow(ctx, createBrand,
		arg.Name,
		arg.Logo,
		arg.Isdeleted,
		arg.Isblocked,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteBrand = `-- name: DeleteBrand :one
DELETE FROM brands WHERE id = $1
RETURNING id
`

func (q *Queries) DeleteBrand(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, deleteBrand, id)
	err := row.Scan(&id)
	return id, err
}

const selectAllBrands = `-- name: SelectAllBrands :many
SELECT id, name, logo, isdeleted, isblocked, created_at FROM brands
`

func (q *Queries) SelectAllBrands(ctx context.Context) ([]Brand, error) {
	rows, err := q.db.Query(ctx, selectAllBrands)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Brand{}
	for rows.Next() {
		var i Brand
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Logo,
			&i.Isdeleted,
			&i.Isblocked,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectBrands = `-- name: SelectBrands :one
SELECT id, name, logo, isdeleted, isblocked, created_at FROM brands WHERE id = $1
`

func (q *Queries) SelectBrands(ctx context.Context, id int32) (Brand, error) {
	row := q.db.QueryRow(ctx, selectBrands, id)
	var i Brand
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Logo,
		&i.Isdeleted,
		&i.Isblocked,
		&i.CreatedAt,
	)
	return i, err
}

const updateBrand = `-- name: UpdateBrand :one
UPDATE brands
SET name = $2, logo = $3, isdeleted = $4, isblocked = $5
WHERE id = $1
RETURNING id
`

type UpdateBrandParams struct {
	ID        int32       `json:"id"`
	Name      string      `json:"name"`
	Logo      pgtype.Text `json:"logo"`
	Isdeleted pgtype.Bool `json:"isdeleted"`
	Isblocked pgtype.Bool `json:"isblocked"`
}

func (q *Queries) UpdateBrand(ctx context.Context, arg UpdateBrandParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateBrand,
		arg.ID,
		arg.Name,
		arg.Logo,
		arg.Isdeleted,
		arg.Isblocked,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}
